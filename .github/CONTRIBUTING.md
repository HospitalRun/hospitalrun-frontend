# Contributing to the Ember front end for HospitalRun

Contributions are welcome via pull requests and issues.  This project uses the style guides from Dockyard for [Ember](https://github.com/dockyard/styleguides/blob/master/engineering/ember.md) and [JavaScript](https://github.com/dockyard/styleguides/blob/master/engineering/javascript.md).  These style guides are enforced via [Ember Suave](https://github.com/dockyard/ember-suave).  Before submitting a pull request, please make sure all tests pass by running ```ember test```.

## Slack / Communication

Project communication occurs primarily and intentionally via our project [Slack](https://hospitalrun.slack.com/). Those interested in / considering contribution are encouraged to [join](https://hospitalrun-slackin.herokuapp.com/).

## Help Wanted

If you're looking for a way to contribute, the [Help Wanted](https://github.com/HospitalRun/hospitalrun-frontend/labels/Help%20Wanted) tag is the right place to start. Those issues are intended to be bugs / features / enhancements / technologies that have been vetted and we know we want to include in the project.

## In Progress

Issues (normally ones that were listed as Help Wanted) where people have committed to working on and delivering the issue are marked with the [In Progress](https://github.com/HospitalRun/hospitalrun-frontend/labels/Help%20Wanted) tag. Project maintainers will review status on those issues weekly and - if status changes - move the issue our of In Progress and back to Help Wanted in appropriate.

## Needs Requirements

[Needs Requirements](https://github.com/HospitalRun/hospitalrun-frontend/labels/Needs%20Requirements) is a tag we use to designate that someone with analyst interests / skills can/could/is needed to work out and document the requirements for the given issue. Simple requirements (or frankly anything that can be) should be recorded in the issue. More complicated formatting our documentation could be stored in the project wiki. To be honest, we're working this out still. So if you're interested in helping us sort out requirements, email joel@cure.org.

## Selecting a Issue / Feature to which you wish to contribute

This guide assumes a level of knowledge on how to use GitHub issues and pull requests. If you choose to contribute code, the standard procedure would to do the following:

1. Fork the master repo.
2. Add a comment in the given issue, referencing @tangollama to let our product management function know your intentions.
3. Use the GitHub issue to converse regarding requirements.
4. Submit a pull request at the point that you feel the feature is "ready to show."

## Guidelines for submitting a Pull Request

- When opening a PR for a specific issue already open, please use the `address #[issue number]` or `closes #[issue number]` syntax in the pull request description.
- Please keep your changes succinct in scope. Large pull requests with multiple changes to the codebase (i.e. multiple features) may be asked to be broken into multiple smaller pull requests.
- Please give as much detail as is relevant about your approach to the solution in the pull request description.
- When your code changes include any change to the visual UI, please include a screenshot of how your changes appear in the browser.

## Start Coding

This section is designed to help developers start coding in the project and understand the basic concepts and components used.

### Ember

To understand the project you'll have to understand [Ember](http://emberjs.com), and it is advisable that you'll follow the tutorial: [Create your own app](https://guides.emberjs.com/v2.9.0/tutorial/ember-cli/) to get an understanding of how Ember works and the basic folder structure. You can find more Ember guides [here](https://guides.emberjs.com/v2.9.0/).

### ES6

Since the project is based on Ember, it uses the ES6 standard for its client side code.

### Folder structure

The basic folder structure in Ember has the following folders and files:

| Folder Name | Purpose |
| ----------- | ------- |
| app/router.js | Defines routes and sub-routes in the application.
| app/index.html | The basic index html of the system (this file should almost never be changed).
| public/ | This directory contains assets such as images and fonts.
| vendor/ | This directory is where front-end dependencies (such as JavaScript or CSS) that are not managed by Bower go.
| dist/ | This folder is auto-generated by ember to contain all the project's compiled files and dependencies so that this folder can be copied as a stand-alone unit to be deployed on a server.
| tmp | Ember CLI temporary files live here.
| ember-cli-build.js | This file is an instruction on how to build the application.

In addition, these are descriptions of some extra folders and files in use in this project:

| Folder Name | Purpose |
| ----------- | ------- |
| server/ | This folder contains the basic definition for the application's backend.
| server/config.js | Basic configuration for the system, like CouchDB config, authentication etc.


### Pod directories

This project uses a folder structure called [Pods](http://cball.me/organize-your-ember-app-with-pods/) that is better suited for a large scale Ember application.

The basic folder structure for Ember puts controllers, routes and templates in three different directories. The Pods approach organizes the folders in correlation to the application routes and keeps all three files in the same folder for each view. 

### Extensions, Mixins & Abstracts

This project has a massive usage of npm modules for Ember, [Ember mixins](http://emberjs.com/api/classes/Ember.Mixin.html) and abstracts.

[ember-simple-auth](https://ember-simple-auth.com/) is an example of an Ember npm module used in the project to enable authentication and authorization.

[app/mixins/number-format.js](/app/mixins/number-format.js) is a mixin that, when augmenting a class, adds functions to it for working with numbers. 

[app/controllers/abstract-paged-controller.js](/app/controllers/abstract-paged-controller.js) is an abstract that takes care of paging and displaying results.
Using it is done like this:

```js
import AbstractEditController from 'hospitalrun/controllers/abstract-edit-controller';
export default AbstractEditController.extend({
...
});
```

### Building the solution

Once you run `script/server` or `ember serve` the project is built and run. Afterwards you can change the models, controllers and templates and Ember will automatically update those files.

You can use `ember build` to actively build a project or `ember build --environment=production` to build the project for production.

### dist/ folder

`dist/` is an automatically generated folder by ember that contains all the dependencies for the project to run. You can copy this folder as is to your server which is a simple way to deploy the project (There are other ways which are not mentioned here).

### Ember data

To make requests to the server the project utilizes [Ember Data](http://emberjs.com/api/data/) and [REST Adapter](http://emberjs.com/api/data/classes/DS.RESTAdapter.html) to control requests between the client and the server.

### Adapters

Ember, by default uses [JSON API](http://jsonapi.org) as a JSON convention. [CouchDB](http://couchdb.apache.org/) uses a different JSON convention. For that reason, an adapter ([app/adapters/application.js](app/adapters/application.js) which uses [ember-pouch](https://github.com/nolanlawson/ember-pouch)) was put between client to server communications to change server bound requests to CouchDB JSON format and client bound responses to JSON API format.

### Components in use

[Ember components](http://emberjs.com/api/classes/Ember.Component.html) are reusable controls that you can integrate inside other pages/components.

### Using Local Cache

The database of **HospitalRun** uses [CouchDB](http://couchdb.apache.org/) to store all of its data online.
In parallel, it uses the offline feature of [PouchDB](https://pouchdb.com/) to store an offline copy of the database which syncs with the online instance on a different thread whenever the application is online.

### Data Access Flow

There are 3 database elements in play:

1. Cloud based CouchDB
2. PouchDB Online for online requests
3. PouchDB Offline for synchronizing  data on a separate thread

The application tries to access data via PouchDB Online which tries to access data on the online CouchDB. If this request succeeds no more actions are required.
As a failover mechanism, all outbound requests are monitored by the PouchDB service so they can be redirected to the local offline PouchDB instance.

The main reason for keeping two services of PouchDB on the client side is that keeping the PouchDB on the main thread, causes the UI to run slowly whenever a sync is running.

### Conflicts

When there's a conflict in data, as long is the conflict occures between two different records or two different fields, the conflict resolution will be able to solve the conflict.
If the conflict is between two versions of the same field, the later record value will apply.
